%!TEX root = ../AGC_Report_Bot_Maathuis.tex

\section{Evaluation}
\label{sec:evaluation}

% Explain what is evaluated
In this section the results of PN triangles are discussed. The visual differences of the normal patches are compared. PN triangles are compared to Loop subdivision. Finally PN triangles are compared with different alternatives.

\subsection{Normal Patches}
\label{sec:evaluation_normals}

% Show the different normal patches
% Choose the best results
Section~\ref{sec:concept_normals} specified four different ways to compute the normals of PN triangles: the analytic normals, linearly interpolated normals, normals computed with a quadratic B\'ezier patch (Equation~\eqref{eq:quadratic_bernstein}) and normals computed as in~\cite{vlachos2001} (Equation~\eqref{eq:quadratic_normals}).

Figure~\ref{fig:tetra} illustrates the visual differences when using the different methods. The figure shows a tetrahedron mesh with one open face. As a result the geometry of the PN triangles contains inflections.

The top left corner shows linearly interpolated normals. These normals do not respect the inflections in the geometry. The top right corner shows the analytic normals. The edges of the triangles appear very sharp with this method. However, it does respect inflections as can be seen at the top of the tetrahedron.

Both bottom figures use a quadratic normal patch. The left one uses the evaluation of~\cite{vlachos2001} (Equation~\eqref{eq:quadratic_normals}), which does not partition unity. The right one uses quadratic Bernstein basis functions (Equation~\eqref{eq:quadratic_bernstein}). The visual differences between the two are small, except that the edge is a bit more prominent on the right.

\begin{figure}[t]
  \centering
      \includegraphics[width=\columnwidth]{figs/open_tetra_normals.png}
  \caption{Top left: linear normals. Top Right: analytic normals. Bottom left: normals as described in~\cite{vlachos2001}. Bottom Right: quadratic B\'ezier normals.}
\label{fig:tetra}
\end{figure}

A better visual difference between both quadratic normal methods is shown in Figure~\ref{fig:torus}. This figure shows a torus mesh. The bottom left figure uses Equation~\eqref{eq:quadratic_normals}, the bottom right figure uses Equation~\eqref{eq:quadratic_bernstein}. Our preference goes to the bottom right figure, because it appears smoother. Besides the formula makes sense mathematically as it partitions unity whereas the equation used in the top plot does not.

All further figures using PN triangles use the normal method as specified in Equation~\eqref{eq:quadratic_bernstein}, unless specified otherwise.

\begin{figure}[t]
  \centering
      \includegraphics[width=\columnwidth]{figs/torus_quadratic.png}
  \caption{Top left: a wire-frame rendering of the mesh. Top right: the mesh rendered with Phong shading. Bottom left: PN triangles of the mesh with normals of Equation~\eqref{eq:quadratic_normals}. Bottom right: PN triangles of the mesh with normals of Equation~\eqref{eq:quadratic_bernstein}.}
\label{fig:torus}
\end{figure}

\subsection{Visual Results}
\label{sec:evaluate_visuals}

% Compare PN-Triangles against loop subdivision
% Explain the trade-off
PN triangles only use the information of a single triangle to construct a cubic B\'ezier patch. Loop subdivision uses the neighboring information of the triangles to recursively generate more triangles. This is much more computation expensive, but the visual results are better because the limit surfaces are $C^2$ everywhere except at extraordinary vertices. In that case the continuity is $C^1$.

PN Triangles were designed to be an inexpensive means of improving visuals. It smooths silhouette edges and provides more sample points for the vertex shading operations. In Figure~\ref{fig:susanne} enabling PN triangles (bottom right) provides improved visuals over the coarse mesh (top right). However when comparing the PN triangles method to Loop subdivision (bottom-left) it is evident that using PN triangles does not result into designer-quality meshes.

The inner and outer tessellation values influence the smoothness of the mesh. The higher the tessellation levels, the smoother the mesh will be. This is because the primitives are broken down into smaller pieces.

Since the computation of PN triangles are relatively cheap, it can be used in real-time rendering applications in contrast to subdivision methods such as Catmull-Clark and Loop.

\begin{figure}[t]
  \centering
      \includegraphics[width=\columnwidth]{figs/susanne_loop_pn.png}
  \caption{Top left: a wire-frame rendering of the mesh. Top Right: the mesh rendered with Phong shading. Bottom left: Loop subdivision level 2. Bottom Right: PN triangles with tessellation levels set to 10.}
\label{fig:susanne}
\end{figure}

\subsection{Hardware Performance}
\label{sec:evaluation_hardware}

\begin{table}[b]
\centering
\caption{The number of vector operations used in the implementation for computing the control points per patch.}
\label{tab:tc_operations}
\begin{tabular}{lll}
                   & Geometry Patch & Normal Patch \\
Vector assignment  & 12  & 6  \\
Vector addition    & 15  & 6  \\
Vector subtraction & 12  & 12 \\
Vector scaling (*) & 14  & 3  \\
Vector scaling (/) & 8   & 3  \\
Dot product        & 6   & 9
\end{tabular}
\end{table}

\begin{table*}[t]
\centering
\caption{The number of vector operations used in the implementation for evaluating the geometry and normal patches. The values are per vertex, including the vertices of the original triangle.}
\label{tab:te_operations}
\begin{tabular}{lllll}
 & Geometry & Linear Normals & Quadratic Normal & Analytic Normals \\
Vector assignment & 3 & 2 & 2 & 5 \\
Vector addition & 10 & 3 & 6 & 20 \\
Vector subtraction & 0 & 0 & 0 & 0 \\
Vector scaling (*) & 10 & 3 & 6 & 20 \\
Vector scaling (/) & 0 & 1 & 1 & 1 \\
Dot product & 0 & 1 & 1 & 1 \\
Cross product & 0 & 0 & 0 & 1 \\
Matrix multiplication & 1 & 0 & 0 & 0 \\
Matrix vector multiplication & 2 & 1 & 1 & 1
\end{tabular}
\end{table*}

% Number of vector operations
The performance impact of PN triangles has been estimated with the number of vertex operations performed per generated vertex. The original implementation used between $6.8$ and $11.6$ vector operations per vertex, depending on the lod value~\cite{vlachos2001}. Vector operations include dot products, additions of two vectors, scaling of a vector and per element multiplication of two vectors.

The number of vector operations in our implementation are given in Tables~\ref{tab:tc_operations} and~\ref{tab:te_operations}. The former table shows the number of vertex operations used in computing the geometry and normal control points. These values are per patch and independent of the number of generated vertices.

The latter table shows the number of vertex operations used in evaluating the geometry control patch and the different normal methods. These values are per vertex, including the vertices of the initial triangle.

Our implementation uses more vector operations per vertex than mentioned in~\cite{vlachos2001}. Suppose the tessellation levels are set to $4$ then a total of $19$ vertices are used per triangle. We require between $30.9$ to $64.8$ vector operations per vertex to evaluate the geometry and normals of a PN triangle; excluding vector assignments, cross products and matrix operations. These values are calculated by dividing the number of vertex operation used to compute the control patches by the number of vertices, and adding the number of operations per vertex to evaluate the geometry and normals.

% difference between generating and rendering a highly tessellated mesh
Regardless of the difference in implementation, generating additional vertices is more efficient than using highly tessellated meshes. An NVIDIA GTX 780 graphics card is able to render a planar mesh with 2 million polygons in about $1.5$ms. Generating the same mesh using hardware tessellation only requires $0.25$ms~\cite{niessner2015}. So using PN triangles as a type of \emph{geometry compression} is more efficient than using a denser mesh.

% Compare with subdivision (static vs dynamic mesh)
This result is also relevant in a comparison with Loop subdivision. Even when meshes are static (they do not need to be subdivided at run time) it is probably more computationally expensive to render the subdivided mesh than to apply PN triangles to the coarse mesh.

\subsection{Alternatives}
% Compare with alternatives

Four alternatives are introduced in Section~\ref{sec:introduction_alternatives}. They are QAS, Phong Tessellation, ACC-1 and ACC-2. This section compares the methods with PN triangles.

QAS uses a quadratic B\'ezier patch constructed from the limit positions of the mesh after one subdivision step~\cite{qas2008}. A quadratic B\'ezier patch is argued to result in good enough visuals because the method interpolates the limit positions of the mesh.

However, by subdividing and projecting the mesh to the limit QAS limits the situations in which it is usable. The computational cost could become too large when meshes are animated and have to be subdivided every frame. If the meshes are static evaluating QAS is cheaper to evaluate than PN triangles as less control points are used.

Phong Tessellation, similar to QAS, uses a quadratic geometry patch, which is cheaper to evaluate than the cubic geometry patch of PN triangles. Both PN triangles and Phong Tessellation can be computed in one rendering pass. The visuals of Phong Tessellation are \emph{``equally convincing''}~\cite{phongtess2008}.

However, Phong Tessellation has a disadvantage compared to PN triangles. The inflation of each face has to be set for each mesh, or even for parts of a mesh, in order to get the best results.

ACC-1 and ACC-2 are not directly comparable with PN triangles because they approximate the Catmull-Clark surface of quad meshes. However, they are worth mentioning since both techniques show that subdivision surfaces can be rendered accurately in real-time using hardware tessellation and neighborhood information.

Both methods are able to render subdivision surfaces such that only extraordinary patches are approximated. The only drawback with regards to the visual results is \emph{``the slight disparity artists may encounter between  the surface displayed by their content creation tools and the one that is rendered in realtime''}~\cite{acc22009}.

Compared to PN triangles both ACC methods make a different trade-off in performance and quality.
